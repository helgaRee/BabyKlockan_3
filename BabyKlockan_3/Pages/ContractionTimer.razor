@page "/contractionTimer"
@using BabyKlockan_3.Models
@using BabyKlockan_3.Services
@inject ContractionService contractionService


<!--HANTERING AV LOGIK FÖR ATT LÄGGA TILL EN NY VÄRK-->
<!--KOMMUNICERAR MED CONTRACTIONSERVICE-->
<!-- samlar och hanterar data om värkarna.-->


 <button @onclick="ToggleTimer" class="btn-circle @(!isRunning ? "btn-start" : "btn-stop")">
    @(isRunning ? "Stoppa" : "Starta")
</button> 

<h3>Tid: @elapsedTime</h3>

<!--Skicka listan till ContractionList-komponenten-->
<ContractionList contractions="@contractions" OnContractionChange="UpdateContractions" />
<ContractionSummary contractionsPerTenMinutes="@contractionsPerTenMinutes" />




@code {

    private bool isRunning = false;
    //sparar starttiden
    private DateTime? startTime;
    private DateTime? endTime;
    //mätningens längd
    private TimeSpan? duration;
    private string elapsedTime = "00:00";
    private Timer? timer;


    //deklarerar contractions
    private List<ContractionModel> contractions = new List<ContractionModel>();

    private double contractionsPerTenMinutes;
    private double averageDuration;
    private double averageRestTime;

    //metoden styg logik för start/stopp
    private async Task ToggleTimer()
    {
        if(!isRunning)
        {
            isRunning = true;
            StartTimer();
        } else
        {
            await StopTimer();
            isRunning = false;
        }

        // isRunning = !isRunning;
        StateHasChanged();
    }


    /// <summary>
    /// Timern startas vid klick, och tiden uppdateras kontinuerligt
    /// </summary>
    private void StartTimer()
    {
        startTime = DateTime.Now;
        //startar en timer som uppdaterar tiden varje sekund
        timer = new Timer(UpdateElapsedTime, null, 0, 1000);
        isRunning = true;
    }


    /// <summary>
    ///  stoppar timern, beräknar värkens duration, sparar den via ContractionService, och återställer startTime och isRunning för nästa värk.
    /// </summary>
    private async Task StopTimer()
    {
        if (startTime.HasValue)
        {
            var endTime = DateTime.Now;

            //Lägger till värk
            contractionService.AddContraction(startTime.Value, endTime);

            //hämta listan från service och uppdatera listan och sammanfattnignen
            contractions = contractionService.GetAllContractions();
            contractionsPerTenMinutes = contractionService.GetContractionsPerTenMinutes();
            averageDuration = contractionService.GetAverageDuration();
            averageRestTime = contractionService.GetAverageRestTime();


            //stoppa timer
            timer?.Dispose();
            timer = null;

            //nollställ klockan
            elapsedTime = TimeSpan.Zero.ToString(@"mm\:ss");

            isRunning = false;
            Console.WriteLine($"Elapsed time: {elapsedTime}");

            StateHasChanged();
        }
    }

    public void UpdateElapsedTime(object? state)
    {
        if (startTime.HasValue)
        {
            var elapsed = DateTime.Now - startTime.Value;
            //visa tid som minuter
            elapsedTime = elapsed.ToString(@"mm\:ss");
            //uppdaerar UI
            InvokeAsync(StateHasChanged);
        }
    }


    //event callback för att ta emot uppdaterad lista
    private void UpdateContractions(List<ContractionModel> updateContractions)
    {
        contractions = updateContractions;
    }

}
