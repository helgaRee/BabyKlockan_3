@page "/contractionTimer"
@using BabyKlockan_3.Models
@using BabyKlockan_3.Services
@inject ContractionService contractionService


<!--HANTERING AV LOGIK FÖR ATT LÄGGA TILL EN NY VÄRK-->
<!--KOMMUNICERAR MED CONTRACTIONSERVICE-->
<!-- samlar och hanterar data om värkarna.-->


 <button @onclick="ToggleTimer" class="btn-circle @(!isRunning ? "btn-start" : "btn-stop")">
    @(isRunning ? "Stoppa" : "Starta")
</button> 

<h3>Tid: @elapsedTime</h3>

<!--Skicka listan till ContractionList-komponenten-->
<ContractionList contractions="@contractions" OnContractionChange="UpdateContractions" />
<ContractionSummary contractionsPerTenMinutes="@contractionsPerTenMinutes" />




@code {

    private bool isRunning = false;
    //sparar starttiden
    private DateTime? startTime;
    private DateTime? endTime;
    //mätningens längd
    private TimeSpan? duration;
    private string elapsedTime = "00:00";
    private Timer? timer;


    //deklarerar contractions
    private List<ContractionModel> contractions = new List<ContractionModel>();

    private double contractionsPerTenMinutes;
    private double averageDuration;
    private double averageRestTime;



    /// <summary>
    /// metoden styr logik för start/stopp
    /// </summary>
    /// <returns></returns>
    private async Task ToggleTimer()
    {
        if(!isRunning)
        {
            isRunning = true;
            StartTimer();
        } else
        {
            await StopTimer();
            isRunning = false;
        }
        StateHasChanged();


    }


    /// <summary>
    /// Timern startas vid klick, och tiden uppdateras kontinuerligt
    /// </summary>
    private void StartTimer()
    {

        startTime = DateTime.Now;
        //startar en timer som uppdaterar tiden varje sekund
        timer = new Timer(UpdateElapsedTime, null, 0, 1000);
        isRunning = true;



    }


    /// <summary>
    ///  stoppar timern, beräknar värkens duration, sparar den via ContractionService, och återställer startTime och isRunning för nästa värk.
    /// </summary>
    private async Task StopTimer()
    {
        Console.WriteLine("Inne i stoptimer");
        if (startTime.HasValue)
        {
            var endTime = DateTime.Now;

            //Lägger till värk
            await contractionService.AddContractionAsync(startTime.Value, endTime);

            //hämta listan från service och uppdatera listan och sammanfattnignen
            contractions = await contractionService.GetContractionsLastHourAsync();
            contractionsPerTenMinutes = contractionService.GetContractionsPerTenMinutes();
            averageDuration = contractionService.GetAverageDuration();
            averageRestTime = contractionService.GetAverageRestTime();


            //stoppa timer
            timer?.Dispose();
            timer = null;

            //nollställ klockan
            elapsedTime = TimeSpan.Zero.ToString(@"mm\:ss");

            isRunning = false;
            Console.WriteLine($"Elapsed time: {elapsedTime}");

            StateHasChanged();
        }
    }

    /// <summary>
    /// Uppdaterar tiden
    /// </summary>
    /// <param name="state"></param>
    public void UpdateElapsedTime(object? state)
    {
        if (startTime.HasValue)
        {
            var elapsed = DateTime.Now - startTime.Value;
            //visa tid som minuter
            elapsedTime = elapsed.ToString(@"mm\:ss");

            try
            {
                //uppdaterar UI
                InvokeAsync(StateHasChanged);

            }
            catch (ObjectDisposedException)
            {
                
            }
        }
    }


    /// <summary>
    /// En event callback för att ta emot uppdaterad lista
    /// </summary>
    /// <param name="updateContractions"></param>
    private void UpdateContractions(List<ContractionModel> updateContractions)
    {
        contractions = updateContractions;
    }

}
